{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"section\", {\n    \"name\": \"Snippets\",\n    \"depth\": 1\n  }, mdx(\"h1\", {\n    parentName: \"section\"\n  }, \"Snippets\"), mdx(StatusNotice, {\n    mdxType: \"StatusNotice\"\n  }), mdx(\"section\", {\n    parentName: \"section\",\n    \"name\": \"Roadmap\",\n    \"depth\": 2\n  }, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Roadmap\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The exact features of this applet have yet to be determined, but it will generally just provide automatic snippet insertion.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The user would be able to configure that a given piece of text is mapped to some other given piece of text.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":D\"), \" could for instance be mapped to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\uD83D\\uDE04\"), \". Then when the applet is enabled, when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":D\"), \" is typed in any program, it will automatically be replaced with the unicode \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\uD83D\\uDE04\"), \" text.\"), mdx(\"section\", {\n    parentName: \"section\",\n    \"name\": \"Technical details\",\n    \"depth\": 3\n  }, mdx(\"h3\", {\n    parentName: \"section\"\n  }, \"Technical details\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"This applet would require to actively listen to all keypresses of the user when the applet is enabled. We will have to look into how feasible this is (in a stable way without interfering with normal OS keyboard usage) for all of the supported OSes. This technology would also be useful for other applets such as dictionaries or spellcheckers.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Will need to detect clicks, and erase the cached text, in order to prevent incorrect matches.\")))));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<section><style data-emotion=\"css nn640c\">.css-nn640c{-webkit-text-decoration:none;text-decoration:none;color:inherit;}</style><a href=\"#snippets\" class=\"css-nn640c\"><h1>Snippets</h1></a><style data-emotion=\"css 16q8120\">.css-16q8120{margin-top:20px;font-size:20px;font-weight:800;}</style><div class=\"css-16q8120\"><span aria-label=\"Nothing has been implemented yet\" class=\"\"><style data-emotion=\"css 1cd6ilh\">.css-1cd6ilh{color:red;}.css-1cd6ilh >*{vertical-align:bottom;font-size:1.5em;}</style><div class=\"MuiBox-root jss1 css-1cd6ilh\"><svg class=\"MuiSvgIcon-root\" focusable=\"false\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z\"></path></svg></div></span>This applet has not yet been developed, but is on the roadmap.</div><section><style data-emotion=\"css nn640c\">.css-nn640c{-webkit-text-decoration:none;text-decoration:none;color:inherit;}</style><a href=\"#roadmap\" class=\"css-nn640c\"><h2>Roadmap</h2></a><p>The exact features of this applet have yet to be determined, but it will generally just provide automatic snippet insertion.</p><p>The user would be able to configure that a given piece of text is mapped to some other given piece of text.\n<style data-emotion=\"css an0xih\">.css-an0xih{display:inline-block;background-color:#EEEEEE;word-break:break-word;}</style><code class=\"css-an0xih\">:D</code> could for instance be mapped to <style data-emotion=\"css an0xih\">.css-an0xih{display:inline-block;background-color:#EEEEEE;word-break:break-word;}</style><code class=\"css-an0xih\">ðŸ˜„</code>. Then when the applet is enabled, when <style data-emotion=\"css an0xih\">.css-an0xih{display:inline-block;background-color:#EEEEEE;word-break:break-word;}</style><code class=\"css-an0xih\">:D</code> is typed in any program, it will automatically be replaced with the unicode <style data-emotion=\"css an0xih\">.css-an0xih{display:inline-block;background-color:#EEEEEE;word-break:break-word;}</style><code class=\"css-an0xih\">ðŸ˜„</code> text.</p><section><style data-emotion=\"css nn640c\">.css-nn640c{-webkit-text-decoration:none;text-decoration:none;color:inherit;}</style><a href=\"#technical-details\" class=\"css-nn640c\"><h3>Technical details</h3></a><p>This applet would require to actively listen to all keypresses of the user when the applet is enabled. We will have to look into how feasible this is (in a stable way without interfering with normal OS keyboard usage) for all of the supported OSes. This technology would also be useful for other applets such as dictionaries or spellcheckers.</p><p>Will need to detect clicks, and erase the cached text, in order to prevent incorrect matches.</p></section></section></section>","scope":{}},"ToC":[{"name":"Snippets","children":[{"name":"Roadmap","children":[{"name":"Technical details","children":[]}]}]}],"index":{"rootPath":"/applets","items":[{"name":"utility","opened":true,"children":[{"name":"dictionary"},{"name":"notes"},{"name":"file-manager"},{"name":"internet-search"},{"name":"calculator"},{"name":"translator"},{"name":"snippets","selected":true},{"name":"time-tracker"},{"name":"calendar"}]},{"name":"core","opened":false,"children":[{"name":"help"},{"name":"applet-manager"},{"name":"settings-manager"},{"name":"window-manager"},{"name":"session-manager"},{"name":"lm-recorder"},{"name":"theme-manager"},{"name":"undo-redo-manager"},{"name":"user-scripts"}]}]}},"__N_SSG":true}